Observations and Notes



Code
----------------------------------
My programming language of choice is Python. I chose this specific language for several reaons: development is fast, there are many built-in tools to make simple processes seamless, and there are many external libraries available to me that are easy to use (that I am also familiar with). These libraries enable me to navigate directories, do array/matrix operations, plot data, among other tasks that enable me to focus on the actual research.

SciKit is my machine learning library of choice as it seems easy to learn and quick to implement with. Given the time I have I could not use Keras to be compatible with Python 3.6 in the Anaconda environment.



Data Capture
----------------------------------
There are 26 letters in the English alphabet (only counting upper-case letters). In the Spanish alphabet, there are 7 more letters to consider, thus adding to the total of 33 distinct letters.

When drawing each letter, I have to consider the following characteristics for DRAWING:
    1. Starting (x, y) point of the drawing, and therefore the position of the drawn letters.
        * SOLUTION: Translate all points to start from (0,0).
    
    2. My velocity when drawing (can be calculated by taking the difference of consecutive points).
        * SOLUTION: Dr. Gauch mentioned "unit speed" where if there are too little points, add points in the middle of consecutive points that have significant distance from them.
        * NOTE: I was not able to tackle this problem with a satisfactory solution in time.
    
    3. What coordinates are associated with "noise"? 
        - In other words, which parts of a given drawing are not part of the intended letter and are just strokes used to draw the remaining portions of the letter.
        - Much of this noise can be broken down in two ways:
            i. Many coordinates around some position indicates a pause, ignore most of these noisy points.
            ii. Fast strokes indicate what would be a "pen-up" action when writing the letter on paper. I could possibly calculate a speed threshold such that detected speeds above that number would be ignored.
        * NOTE: I was not able to tackle this problem with a satisfactory solution in time.
    
    4. How big the letter drawn is (i.e. time series with different lengths)
        * SOLUTION: Scale all time series in some range [a...b] to be in a certain output range [d...c]
    
    5. Is the letter drawn at an angle?
        * NOTE: I will ignore this case as people usually do not write letters in unusual angles.
    
To make sure I have a decent amount of data, I will have at least 40 training samples for each letter.
    - Minimum total: 33*40 = 1320 samples.



Strategy 1: tracking a brightly-colored object
----------------------------------
a. Procedure for drawing letter
    1. Capture video at 30 frames per second (fps) with a resolution of 640 x 480 on my laptop camera.
    
    2. Capture frame, and thus we capture and process 30 frames every second.
        - To start drawing, the user can press 'd' at any time to start drawing and again to stop. If the user is not drawing, the tracking still occurs but no drawing is done.
    
    3. Given frame in BGR color space, convert to HSV color space.
    
    4. Get the lower and upper hsv thresholds
        - I have the lower limits hardcoded while the upper thresholds are the maximum values
    
    5. Threshold the HSV version of the frame based on the ranges taken and get the mask, this mask will show only the marker that we will draw with.
    
    6. Given the mask (which recall is a binary image), find the contours (simply put, the edges) of marker, which should be a circle.
    
    7. Draw the contours on the current frame to check that we are finding the marker.
    
    8. Draw the minimum enclosing circle to know where our marker is going to "draw" in the air.
    
    9. If the user is drawing, given the information of the minimum enclosing circle, draw colored filled circles onto the drawing image, and impose this image onto the frame. 
        - The (x, y) coordinates are also added to lists that store the x and y coordinates separately.
        - The overlaying of the drawing onto the frame is done by a series of bitwise AND operations. We want the colored drawing (recall it is on a black background) to be overlayed on top of the frame.
    
    10. Repeat steps 2-9 until the user presses the 'd' key to stop drawing their letter of choice. The final drawing is saved in a (299 x 299)



Strategy 2: Histogram-based approach
----------------------------------
x



Observations
----------------------------------
Tracker:
    - Success: 
        - The tracker in its current state is able to track my bright-green marker well. The tracker works best if:
            - backgroud is simple;
            - well lit, specifically, if a bright-enough light source is in front of me;
            - not many moving objects;
            - nothing matches the color of the pen (this can include other warm colors, or when yellow and blue are together).
        The tracker does not work well if:
            - the environment is not well lit;
            - the brighest light source is behind me, this makes it more diificult to pick up the right color;
            - other objects whose color might interfere with the capture.
    - If there is another bright-green object in the room it may misidentify it. Lighting using the HSV color space does mitigate the effects of lighting but too much or too little will interfere with the tracking.
    - In my time recording data, my drawing arm would usually get noticeally slightly tired after about 15 individual drawings. This coincides with the Georgia Tech source.

First round of data capturing (did not include accent-marked letters):
    - The letter E was by far the most difficult to draw.
    - The letter J had the most variation thus far.
    * At times when I was recording, the tracker seemed to stop tracking for several frames (at most half a second) and thus no data was captured for a small time frame. This resulted in the images (and time series) having "gaps" when they were drawn. This is most likely due to the lighting not being optimal enough at the time of recording.
    * TODO: record more data, at least 9 more for each letter, try to make these more uniform in terms of how they're drawn.

Terms:
    - Captured image and time series: this is the drawing and associated data that was just captured which represents the air-written letter.
    - Query image and time series: this is the fetched image and associated time series.

Time series analysis
    - The start-at-zero, equalize time series lengths, and map-to-scale operations should not interfere with each other. I apply each of these transformations to the time series for the captured and query time series.
    - Dynamic time warping is my time series-based classifier

Machine learning classifiers
    - K-nearest neighbors (knn)
        - This algorithm works best if all the classes are huddled together and as away from other class points as possible. If there is overlap, there will be problems with the classification.
        - One thing I noticed that could be a problem is when the set of k nearest neighbors is multimodal, that is, the mode for two or more letters is the same. Right now I do not have any procedure to account for that.
    - Nearest centroid
        - Very close in terms of implementation to knn
    - Support Vector Machine (take in images as inputs, where we train on grayscale values).
        - Apparently SVMs are difficult to implement, according to some sources.
        - SciKit fortunately offers a SVM classifier which seems easy to call, I just have to feed it a single array that represents the grayscale image. According to the SciKit SVM docs:
            * The advantages of support vector machines are:
                - Effective in high dimensional spaces.
                - Still effective in cases where number of dimensions is greater than the number of samples.
                - Uses a subset of training points in the decision function (called support vectors), so it is also memory efficient.
                - Versatile: different Kernel functions can be specified for the decision function. Common kernels are provided, but it is also possible to specify custom kernels.
            
            * The disadvantages of support vector machines include:
                - If the number of features is much greater than the number of samples, avoid over-fitting in choosing Kernel functions and regularization term is crucial.
                - SVMs do not directly provide probability estimates, these are calculated using an expensive five-fold cross-validation (see Scores and probabilities, below).
        
        - Resources
            - https://scikit-learn.org/stable/modules/svm.html
            - (some tutorial) https://monkeylearn.com/blog/introduction-to-support-vector-machines-svm/



Definitions
----------------------------------
* RGB: The red, green, and blue (RGB) color space is a very widely-used color space where each color value varies from 0 to 255. Adding varying amounts of these colors allows for the creation of other colors. The OpenCV library switches the placement of red and blue and thus uses the "BGR" color space.

* HSV: The hue, saturation, and value (HSV) color space is another way to represent color. It treats the hue (color) as a singular value from 0 to 359 degrees where each angle corresponds to a color. The saturation handles the intensity of the color, 0% being a gray, while 100% denotes a strong color. The value is the illumination, which ranges from 0% to 100%, and this handles the lightness. This allows the HSV color space to better handle color identification in different lighting situations.
    - 

* x
